# app/strategies/base_strategy.py
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
from enum import Enum
import pandas as pd
from pydantic import BaseModel, Field

class OrderType(Enum):
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP_LOSS = "STOP_LOSS"
    STOP_LOSS_LIMIT = "STOP_LOSS_LIMIT"

class OrderSide(Enum):
    BUY = "BUY"
    SELL = "SELL"

class Signal(BaseModel):
    """Trading signal generated by strategy"""
    symbol: str
    side: OrderSide
    quantity: int
    order_type: OrderType = OrderType.MARKET
    price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Dict[str, Any] = Field(default_factory=dict)
    timestamp: datetime = Field(default_factory=datetime.utcnow)

class StrategyConfig(BaseModel):
    """Base configuration for all strategies"""
    name: str
    version: str = "1.0.0"
    symbols: List[str]
    timeframe: str = "5minute"  # 1minute, 3minute, 5minute, 15minute, 30minute, 60minute, day
    lookback_periods: int = 100
    parameters: Dict[str, Any] = Field(default_factory=dict)
    
class StrategyState(BaseModel):
    """Runtime state of a strategy"""
    is_active: bool = True
    positions: Dict[str, Any] = Field(default_factory=dict)
    pending_orders: List[Dict[str, Any]] = Field(default_factory=list)
    metrics: Dict[str, float] = Field(default_factory=dict)
    last_update: datetime = Field(default_factory=datetime.utcnow)

class BaseStrategy(ABC):
    """Abstract base class for all trading strategies"""
    
    def __init__(self, config: StrategyConfig):
        self.config = config
        self.state = StrategyState()
        self._data_cache: Dict[str, pd.DataFrame] = {}
        
    @property
    def name(self) -> str:
        return self.config.name
    
    @property
    def symbols(self) -> List[str]:
        return self.config.symbols
    
    @abstractmethod
    def initialize(self) -> None:
        """Initialize strategy (load models, set parameters, etc.)"""
        pass
    
    @abstractmethod
    def on_data(self, symbol: str, data: pd.DataFrame) -> Optional[Signal]:
        """
        Called when new data is available
        
        Args:
            symbol: Trading symbol
            data: DataFrame with OHLCV data and indicators
            
        Returns:
            Trading signal or None
        """
        pass
    
    @abstractmethod
    def on_order_fill(self, order: Dict[str, Any]) -> None:
        """Called when an order is filled"""
        pass
    
    @abstractmethod
    def on_position_update(self, position: Dict[str, Any]) -> None:
        """Called when position is updated"""
        pass
    
    def calculate_position_size(self, symbol: str, signal: Signal, 
                              capital: float, current_price: float) -> int:
        """Calculate position size based on risk management rules"""
        # Default implementation - can be overridden
        max_position_value = capital * 0.02  # 2% of capital
        return int(max_position_value / current_price)
    
    def get_required_indicators(self) -> List[str]:
        """Return list of required technical indicators"""
        return []
    
    def validate_signal(self, signal: Signal) -> Tuple[bool, Optional[str]]:
        """Validate trading signal before execution"""
        if signal.quantity <= 0:
            return False, "Invalid quantity"
        if signal.order_type == OrderType.LIMIT and signal.price is None:
            return False, "Limit order requires price"
        return True, None
    
    def update_metrics(self, trade_result: Dict[str, Any]) -> None:
        """Update strategy performance metrics"""
        # Update win rate, profit factor, etc.
        pass
    
    def get_state(self) -> Dict[str, Any]:
        """Get current strategy state"""
        return self.state.dict()
    
    def set_state(self, state: Dict[str, Any]) -> None:
        """Restore strategy state"""
        self.state = StrategyState(**state)